interface User {
  username: string;
}

// Simulate network delay to mimic a real database call
const delay = (ms: number): Promise<void> => new Promise(res => setTimeout(res, ms));

const USERS_KEY = 'color-picker-users';

// --- Private Helper Functions ---

const getUsers = (): Record<string, string> => {
  try {
    const users = localStorage.getItem(USERS_KEY);
    return users ? JSON.parse(users) : {};
  } catch (e) {
    console.error("Failed to parse users from localStorage", e);
    return {};
  }
};

const saveUsers = (users: Record<string, string>): void => {
  localStorage.setItem(USERS_KEY, JSON.stringify(users));
};

// --- Public AuthService ---

export const authService = {
  async login(username: string, password: string): Promise<User> {
    await delay(500); // Simulate network latency
    const users = getUsers();
    if (users[username] && users[username] === password) {
      return { username };
    }
    throw new Error('Invalid username or password.');
  },

  async signup(username: string, password: string): Promise<User> {
    await delay(500);
    const users = getUsers();
    if (users[username]) {
      throw new Error('Username already exists.');
    }
    users[username] = password;
    saveUsers(users);
    return { username };
  },

  async googleSignup(): Promise<User> {
    await delay(500);
    const users = getUsers();
    let username: string;
    let attempts = 0;
    // Ensure unique username in case of collision
    do {
      const randomId = Math.floor(1000 + Math.random() * 9000);
      username = `google_user_${randomId}`;
      attempts++;
    } while (users[username] && attempts < 10);
    
    if (users[username]) {
        throw new Error("Could not generate a unique Google username.");
    }

    users[username] = `simulated_google_password_${Date.now()}`;
    saveUsers(users);
    return { username };
  },
};
